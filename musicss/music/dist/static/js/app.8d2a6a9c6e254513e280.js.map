{"version":3,"sources":["webpack:///./src/App.vue?cd74","webpack:///./src/App.vue","webpack:///src/App.vue","webpack:///./src/shared/encoder-wav-worker.js","webpack:///./src/shared/encoder-mp3-worker.js","webpack:///./src/shared/encoder-ogg-worker.js","webpack:///./src/shared/RecorderService.js","webpack:///./src/shared/Utils.js","webpack:///src/components/HelloWorld.vue","webpack:///./src/components/HelloWorld.vue?fd01","webpack:///./src/components/HelloWorld.vue","webpack:///./src/router/index.js","webpack:///./src/main.js"],"names":["selectortype_template_index_0_src_App","render","_h","this","$createElement","_c","_self","attrs","id","staticRenderFns","src_App","__webpack_require__","normalizeComponent","name","ssrContext","encoder_wav_worker","BYTES_PER_SAMPLE","recorded","self","onmessage","e","data","buffer","length","Uint8Array","i","index","sample","push","encode","sampleRate","bufferLength","wav","view","DataView","setUint32","setUint16","set","msg","postMessage","dump","close","encoder_mp3_worker","channels","kbps","mp3encoder","maxSamples","mp3Data","convertBuffer","arrayBuffer","Float32Array","out","Int16Array","input","output","s","Math","max","min","floatTo16BitPCM","opts","mp3buf","samplesMono","remaining","left","subarray","encodeBuffer","flush","importScripts","baseUrl","lamejs","Mp3Encoder","encoder_ogg_worker","quality","oggEncoder","oggData","blob","finish","OggVorbisEncoder","RecorderService","classCallCheck_default","window","AudioContext","webkitAudioContext","em","document","createDocumentFragment","state","chunks","chunkType","usingMediaRecorder","MediaRecorder","encoderMimeType","config","broadcastAudioProcessEvents","createAnalyserNode","createDynamicsCompressorNode","forceScriptProcessor","manualEncoderId","micGain","processorBufferSize","stopTracksAndCloseCtxWhenFinished","userMediaConstraints","audio","fn","js","toString","replace","Blob","Worker","URL","createObjectURL","timeslice","_this","navigator","mediaDevices","getUserMedia","audioCtx","micGainNode","createGain","outputGainNode","dynamicsCompressorNode","createDynamicsCompressor","analyserNode","createAnalyser","processorNode","createScriptProcessor","createMediaStreamDestination","destinationNode","destination","encoderWorker","createWorker","BASE_URL","addEventListener","event","Event","type","_onDataAvailable","then","stream","_startRecordingWithStream","microphone","createMediaStreamSource","processor","connect","console","log","onaudioprocess","array","inputBuffer","getChannelData","write","catch","error","alert","message","newGain","gain","setValueAtTime","currentTime","_this2","micAudioStream","inputStreamNode","context","onGraphSetupWithInputStream","nextNode","_onAudioProcess","mediaRecorder","evt","_onError","start","slicing","setInterval","dispatchEvent","CustomEvent","detail","outputBuffer","stop","clearInterval","blobUrl","recording","ts","Date","getTime","mimeType","size","disconnect","getTracks","forEach","track","shared_Utils","Utils","createClass_default","key","value","bytes","si","thresh","abs","units","u","toFixed","userAgent","match","HelloWorld","filters","fileSizeToHumanSize","val","humanFileSize","recordingInProgress","supportedMimeTypes","recordings","micGainSlider","cleanupWhenFinished","addDynamicsCompressor","created","recorderSrvc","shared_RecorderService","onNewRecording","watch","setMicGain","methods","startRecording","stopRecording","components_HelloWorld","_vm","on","click","_v","_l","idx","src","controls","src_components_HelloWorld","HelloWorld_normalizeComponent","vue_esm","use","vue_router_esm","router","routes","path","component","productionTip","el","components","App","template"],"mappings":"qHAGAA,GADiBC,OAFjB,WAA0B,IAAaC,EAAbC,KAAaC,eAA0BC,EAAvCF,KAAuCG,MAAAD,IAAAH,EAAwB,OAAAG,EAAA,OAAiBE,OAAOC,GAAA,SAAYH,EAAA,oBAE5GI,oBCCjB,IAuBAC,EAvBAC,EAAA,OAcAC,ECTAC,KAAA,ODWAb,GATA,EAVA,SAAAc,GACAH,EAAA,SAaA,KAEA,MAUA,8DEzBAI,EAAA,WAEE,IAAIC,EAAmB,EACnBC,KAgEJC,KAAKC,UAAY,SAAUC,GACP,WAAdA,EAAEC,KAAK,GA/Db,SAAiBC,GAGf,IAFA,IAAIC,EAASD,EAAOC,OAChBF,EAAO,IAAIG,WAAWD,EAASP,GAC1BS,EAAI,EAAGA,EAAIF,EAAQE,IAAK,CAC/B,IAAIC,EAAQD,EAAIT,EACZW,EAASL,EAAOG,GAChBE,EAAS,EACXA,EAAS,EAEFA,GAAU,IACjBA,GAAU,GAEZA,GAAkB,MAClBN,EAAKK,GAASC,EACdN,EAAKK,EAAQ,GAAKC,GAAU,EAE9BV,EAASW,KAAKP,GAgDZQ,CAAOT,EAAEC,KAAK,IAEO,SAAdD,EAAEC,KAAK,GA/ClB,SAAeS,GACb,IAAIC,EAAed,EAASM,OAASN,EAAS,GAAGM,OAAS,EACtDA,EAASN,EAASM,OAASQ,EAC3BC,EAAM,IAAIR,WAAW,GAAKD,GAE1BU,EAAO,IAAIC,SAASF,EAAIV,QAG5BW,EAAKE,UAAU,EAAG,YAAY,GAE9BF,EAAKE,UAAU,EAAG,GAAKZ,GAAQ,GAE/BU,EAAKE,UAAU,EAAG,YAAY,GAE9BF,EAAKE,UAAU,GAAI,YAAY,GAE/BF,EAAKE,UAAU,GAAI,IAAI,GAEvBF,EAAKG,UAAU,GAAI,GAAG,GAEtBH,EAAKG,UAAU,GAAI,GAAG,GAEtBH,EAAKE,UAAU,GAAIL,GAAY,GAE/BG,EAAKE,UAAU,GAAIL,EAAad,GAAkB,GAElDiB,EAAKG,UAAU,GAAIpB,GAAkB,GAErCiB,EAAKG,UAAU,GAAI,EAAIpB,GAAkB,GAEzCiB,EAAKE,UAAU,GAAI,YAAY,GAE/BF,EAAKE,UAAU,GAAIZ,GAAQ,GAE3B,IAAK,IAAIE,EAAI,EAAGA,EAAIR,EAASM,OAAQE,IACnCO,EAAIK,IAAIpB,EAASQ,GAAIA,EAAIM,EAAe,IAG1Cd,KACA,IAAIqB,GAAON,EAAIV,QACfiB,YAAYD,GAAMA,EAAI,KAQpBE,CAAKpB,EAAEC,KAAK,IAES,UAAdD,EAAEC,KAAK,IACdH,KAAKuB,UCzEXC,EAAA,WAKE,IAAIC,EAAW,EAEXC,EAAO,IAEPC,EAAa,KAEXC,EAAa,KAEfC,KAeJ,SAASC,EAAeC,GACtB,IAAI5B,EAAO,IAAI6B,aAAaD,GACxBE,EAAM,IAAIC,WAAWH,EAAY1B,QAErC,OAXF,SAA0B8B,EAAOC,GAC/B,IAAK,IAAI7B,EAAI,EAAGA,EAAI4B,EAAM9B,OAAQE,IAAK,CACrC,IAAI8B,EAAIC,KAAKC,KAAK,EAAGD,KAAKE,IAAI,EAAGL,EAAM5B,KACvC6B,EAAO7B,GAAM8B,EAAI,EAAQ,MAAJA,EAAiB,MAAJA,GAOpCI,CAAgBtC,EAAM8B,GACfA,EA0CThC,UAAY,SAAUC,GA3DtB,IAAewC,EAqCTC,EAuBc,WAAdzC,EAAEC,KAAK,GAxCb,SAAiB4B,GAGf,IAFA,IAAIa,EAAcd,EAAcC,GAC5Bc,EAAYD,EAAYvC,OACnBE,EAAI,EAAGsC,GAAa,EAAGtC,GAAKqB,EAAY,CAC/C,IAAIkB,EAAOF,EAAYG,SAASxC,EAAGA,EAAIqB,GACnCzB,EAAOwB,EAAWqB,aAAaF,GACnCjB,EAAQnB,KAAKP,GACb0C,GAAajB,GAkCbjB,CAAOT,EAAEC,KAAK,IAEO,SAAdD,EAAEC,KAAK,IACTD,EAAEC,KAAK,IA3BVwC,EAAShB,EAAWsB,SACb5C,OAAS,GAClBwB,EAAQnB,KAAKiC,GAIftB,YAAYQ,GAaZA,MAUuB,SAAd3B,EAAEC,KAAK,IAlEHuC,EAmENxC,EAAEC,KAAK,GAjEd+C,cAAcR,EAAKS,QAAU,iCAC7BxB,EAAa,IAAIyB,OAAOC,WAAW5B,EAAUiB,EAAK9B,WAAYc,IAkEvC,UAAdxB,EAAEC,KAAK,IACdH,KAAKuB,UCxFX+B,EAAA,WACE,IAAI7B,EAAW,EACX8B,EAAU,GAEVC,EAAa,KAEbC,KAmCJxD,UAAY,SAAUC,GAjCtB,IAAewC,EAmBTgB,EANW3B,EACX5B,EAoBc,WAAdD,EAAEC,KAAK,IArBI4B,EAsBN7B,EAAEC,KAAK,GArBZA,EAAOqD,EAAW7C,QAAQoB,IAC9B0B,EAAQ/C,KAAKP,IAsBU,SAAdD,EAAEC,KAAK,IACTD,EAAEC,KAAK,GAnBVuD,EAAOF,EAAWG,OAAO,aAG7BtC,YAAYqC,GAQZD,MAUuB,SAAdvD,EAAEC,KAAK,IAxCHuC,EAyCNxC,EAAEC,KAAK,GAhCd+C,cAAcR,EAAKS,QAAU,yCAC7BK,EAAa,IAAII,iBAAiBlB,EAAK9B,WAAYa,EAAU8B,IAiCtC,UAAdrD,EAAEC,KAAK,IACdH,KAAKuB,uBC/CT,SAAAsC,EAAaV,GAASW,IAAA7E,KAAA4E,GACpB5E,KAAKkE,QAAUA,EAEfY,OAAOC,aAAeD,OAAOC,cAAgBD,OAAOE,mBAEpDhF,KAAKiF,GAAKC,SAASC,yBAEnBnF,KAAKoF,MAAQ,WAEbpF,KAAKqF,UACLrF,KAAKsF,UAAY,GAEjBtF,KAAKuF,mBAAqBT,OAAOU,gBAAiB,EAElDxF,KAAKyF,gBAAkB,YAEvBzF,KAAK0F,QACHC,6BAA6B,EAC7BC,oBAAoB,EACpBC,8BAA8B,EAC9BC,sBAAsB,EACtBC,gBAAiB,MACjBC,QAAS,EACTC,oBAAqB,KACrBC,mCAAmC,EACnCC,sBAAuBC,OAAO,qDAIpBC,GACZ,IAAIC,EAAKD,EACNE,WACAC,QAAQ,uBAAwB,IAChCA,QAAQ,KAAM,IACb/B,EAAO,IAAIgC,MAAMH,IACrB,OAAO,IAAII,OAAOC,IAAIC,gBAAgBnC,2CAGxBoC,GAAW,IAAAC,EAAA9G,KACzB,GAAmB,aAAfA,KAAKoF,MAAT,CAKA,GAAK2B,WAAcA,UAAUC,cAAiBD,UAAUC,aAAaC,aAiErE,OA5DAjH,KAAKkH,SAAW,IAAInC,aACpB/E,KAAKmH,YAAcnH,KAAKkH,SAASE,aACjCpH,KAAKqH,eAAiBrH,KAAKkH,SAASE,aAGhCpH,KAAK0F,OAAOG,+BACd7F,KAAKsH,uBAAyBtH,KAAKkH,SAASK,4BAG1CvH,KAAK0F,OAAOE,qBACd5F,KAAKwH,aAAexH,KAAKkH,SAASO,mBAMhCzH,KAAK0F,OAAOI,sBAAwB9F,KAAK0F,OAAOC,8BAAgC3F,KAAKuF,sBACvFvF,KAAK0H,cAAgB1H,KAAKkH,SAASS,sBAAsB3H,KAAK0F,OAAOO,oBAAqB,EAAG,IAK3FjG,KAAKkH,SAASU,6BAChB5H,KAAK6H,gBAAkB7H,KAAKkH,SAASU,+BAGrC5H,KAAK6H,gBAAkB7H,KAAKkH,SAASY,YAIlC9H,KAAKuF,qBAC4B,QAAhCvF,KAAK0F,OAAOK,iBAGd/F,KAAK+H,cAAgB/H,KAAKgI,aAAazF,GACvCvC,KAAK+H,cAAc3F,aAAa,QAAS8B,QAAS+D,SAAUtG,WAAY3B,KAAKkH,SAASvF,cACtF3B,KAAKyF,gBAAkB,cAEgB,QAAhCzF,KAAK0F,OAAOK,iBACnB/F,KAAK+H,cAAgB/H,KAAKgI,aAAa3D,GACvCrE,KAAK+H,cAAc3F,aAAa,QAAS8B,QAAS+D,SAAUtG,WAAY3B,KAAKkH,SAASvF,cACtF3B,KAAKyF,gBAAkB,cAGvBzF,KAAK+H,cAAgB/H,KAAKgI,aAAapH,GACvCZ,KAAKyF,gBAAkB,aAEzBzF,KAAK+H,cAAcG,iBAAiB,UAAW,SAACjH,GAC9C,IAAIkH,EAAQ,IAAIC,MAAM,iBACc,QAAhCtB,EAAKpB,OAAOK,gBACdoC,EAAMjH,KAAOD,EAAEC,KAGfiH,EAAMjH,KAAO,IAAIuF,KAAKxF,EAAEC,MAAOmH,KAAMvB,EAAKrB,kBAE5CqB,EAAKwB,iBAAiBH,MAKnBpB,UAAUC,aAAaC,aAAajH,KAAK0F,OAAOS,sBACpDoC,KAAK,SAACC,GACL1B,EAAK2B,0BAA0BD,EAAQ3B,GACvCC,EAAK4B,WAAa5B,EAAKI,SAASyB,wBAAwBH,GAC5D1B,EAAK8B,UAAY9B,EAAKI,SAASS,sBAAsB,MAAO,EAAG,GAE/Db,EAAK4B,WAAWG,QAAQ/B,EAAK8B,WACzB9B,EAAK8B,UAAUC,QAAQ/B,EAAKI,SAASY,aAGzCgB,QAAQC,IAAIjC,EAAK8B,WACjB9B,EAAK8B,UAAUI,eAAiB,SAAUb,GAEpC,IAAIc,EAAQd,EAAMe,YAAYC,eAAe,GAC7CjE,SAASkE,MAAMH,EAAM,GAAI,YAI5BI,MAAM,SAACC,GACNC,MAAM,4BAA8BD,EAAME,SAC1CV,QAAQC,IAAIO,KApFdC,MAAM,+FAwFEE,GACVzJ,KAAK0F,OAAOM,QAAUyD,EAClBzJ,KAAKkH,UAAYlH,KAAKmH,aACxBnH,KAAKmH,YAAYuC,KAAKC,eAAeF,EAASzJ,KAAKkH,SAAS0C,+DAIrCpB,EAAQ3B,GAAW,IAAAgD,EAAA7J,KAC5CA,KAAK8J,eAAiBtB,EAEtBxI,KAAK+J,gBAAkB/J,KAAKkH,SAASyB,wBAAwB3I,KAAK8J,gBAClE9J,KAAKkH,SAAWlH,KAAK+J,gBAAgBC,QAIjChK,KAAKiK,6BACPjK,KAAKiK,4BAA4BjK,KAAK+J,iBAGxC/J,KAAK+J,gBAAgBlB,QAAQ7I,KAAKmH,aAClCnH,KAAKmH,YAAYuC,KAAKC,eAAe3J,KAAK0F,OAAOM,QAAShG,KAAKkH,SAAS0C,aAExE,IAAIM,EAAWlK,KAAKmH,YAChBnH,KAAKsH,yBACPtH,KAAKmH,YAAY0B,QAAQ7I,KAAKsH,wBAC9B4C,EAAWlK,KAAKsH,wBAGlBtH,KAAKoF,MAAQ,YAETpF,KAAK0H,eACPwC,EAASrB,QAAQ7I,KAAK0H,eACtB1H,KAAK0H,cAAcmB,QAAQ7I,KAAKqH,gBAChCrH,KAAK0H,cAAcsB,eAAiB,SAAC/H,GAAD,OAAO4I,EAAKM,gBAAgBlJ,KAGhEiJ,EAASrB,QAAQ7I,KAAKqH,gBAGpBrH,KAAKwH,cAKP0C,EAASrB,QAAQ7I,KAAKwH,cAGxBxH,KAAKqH,eAAewB,QAAQ7I,KAAK6H,iBAE7B7H,KAAKuF,oBACPvF,KAAKoK,cAAgB,IAAI5E,cAAcxF,KAAK6H,gBAAgBW,QAC5DxI,KAAKoK,cAAclC,iBAAiB,gBAAiB,SAACmC,GAAD,OAASR,EAAKvB,iBAAiB+B,KACpFrK,KAAKoK,cAAclC,iBAAiB,QAAS,SAACmC,GAAD,OAASR,EAAKS,SAASD,KAEpErK,KAAKoK,cAAcG,MAAM1D,KAMzB7G,KAAKqH,eAAeqC,KAAKC,eAAe,EAAG3J,KAAKkH,SAAS0C,aAKrD/C,IACFiC,QAAQC,IAAI,0GACZ/I,KAAKwK,QAAUC,YAAY,WACN,cAAfzK,KAAKoF,OACPpF,KAAK+H,cAAc3F,aAAa,OAAQpC,KAAKgK,QAAQrI,cAEtDkF,6CAKQ5F,GAUXjB,KAAK0F,OAAOC,6BACd3F,KAAKiF,GAAGyF,cAAc,IAAIC,YAAY,kBACpCC,QACE1B,YAAajI,EAAEiI,YACf2B,aAAc5J,EAAE4J,iBAoCjB7K,KAAKuF,oBACW,cAAfvF,KAAKoF,QACHpF,KAAK0F,OAAOC,4BACd3F,KAAK+H,cAAc3F,aAAa,SAAUnB,EAAE4J,aAAa1B,eAAe,KAGxEnJ,KAAK+H,cAAc3F,aAAa,SAAUnB,EAAEiI,YAAYC,eAAe,8CAO1D,aAAfnJ,KAAKoF,QAGLpF,KAAKuF,oBACPvF,KAAKoF,MAAQ,WACbpF,KAAKoK,cAAcU,SAGnB9K,KAAKoF,MAAQ,WACbpF,KAAK+H,cAAc3F,aAAa,OAAQpC,KAAKkH,SAASvF,aACtDoJ,cAAc/K,KAAKwK,oDAWLH,GAOhB,GAHArK,KAAKqF,OAAO5D,KAAK4I,EAAInJ,MACrBlB,KAAKsF,UAAY+E,EAAInJ,KAAKmH,KAEP,aAAfrI,KAAKoF,MAAT,CAIA,IAAIX,EAAO,IAAIgC,KAAKzG,KAAKqF,QAASgD,KAAQrI,KAAKsF,YAC3C0F,EAAUrE,IAAIC,gBAAgBnC,GAC5BwG,GACJC,IAAI,IAAIC,MAAOC,UACfJ,QAASA,EACTK,SAAU5G,EAAK4D,KACfiD,KAAM7G,EAAK6G,MAGbtL,KAAKqF,UACLrF,KAAKsF,UAAY,KAEbtF,KAAK6H,kBACP7H,KAAK6H,gBAAgB0D,aACrBvL,KAAK6H,gBAAkB,MAErB7H,KAAKqH,iBACPrH,KAAKqH,eAAekE,aACpBvL,KAAKqH,eAAiB,MAEpBrH,KAAKwH,eACPxH,KAAKwH,aAAa+D,aAClBvL,KAAKwH,aAAe,MAElBxH,KAAK0H,gBACP1H,KAAK0H,cAAc6D,aACnBvL,KAAK0H,cAAgB,MAEnB1H,KAAK+H,gBACP/H,KAAK+H,cAAc3F,aAAa,UAChCpC,KAAK+H,cAAgB,MAEnB/H,KAAKsH,yBACPtH,KAAKsH,uBAAuBiE,aAC5BvL,KAAKsH,uBAAyB,MAE5BtH,KAAKmH,cACPnH,KAAKmH,YAAYoE,aACjBvL,KAAKmH,YAAc,MAEjBnH,KAAK+J,kBACP/J,KAAK+J,gBAAgBwB,aACrBvL,KAAK+J,gBAAkB,MAGrB/J,KAAK0F,OAAOQ,oCAEdlG,KAAK8J,eAAe0B,YAAYC,QAAQ,SAACC,GAAD,OAAWA,EAAMZ,SACzD9K,KAAK8J,eAAiB,KAEtB9J,KAAKkH,SAAS5E,QACdtC,KAAKkH,SAAW,MAGlBlH,KAAKiF,GAAGyF,cAAc,IAAIC,YAAY,aAAcC,QAASK,UAAWA,wCAGhEZ,GACRvB,QAAQC,IAAI,QAASsB,GACrBrK,KAAKiF,GAAGyF,cAAc,IAAItC,MAAM,UAChCmB,MAAM,SAAWc,YCpVrBsB,EAAA,IA7BA,oBAAAC,IAAA/G,IAAA7E,KAAA4L,GAAA,OAAAC,IAAAD,IAAAE,IAAA,gBAAAC,MAAA,SAEiBC,EAAOC,GACpB,IAAIC,EAASD,EAAK,IAAO,KACzB,GAAI5I,KAAK8I,IAAIH,GAASE,EACpB,OAAOF,EAAQ,KAEjB,IAAII,EAAQH,GACP,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,OAC1C,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OAClDI,GAAK,EACT,GACEL,GAASE,IACPG,QACKhJ,KAAK8I,IAAIH,IAAUE,GAAUG,EAAID,EAAMhL,OAAS,GACzD,OAAO4K,EAAMM,QAAQ,GAAK,IAAMF,EAAMC,MAf1CP,IAAA,cAAAC,MAAA,WAuBI,OAAOhF,UAAUwF,UAAUC,MAAM,mBAC/BzF,UAAUwF,UAAUC,MAAM,iBACzBzF,UAAUwF,UAAUC,MAAM,qBAzBjCZ,EAAA,ICoBAa,GACA/L,KAAA,aACAgM,SACAC,oBADA,SACAC,GACA,OAAAjB,EAAAkB,cAAAD,GAAA,KAGA1L,KAPA,WAQA,OACA4L,qBAAA,EACAC,sBACAC,cACAC,cAAA,IACAjH,QAAA,EACAkH,qBAAA,EACAC,uBAAA,IAGAC,QAlBA,WAkBA,IAAAtG,EAAA9G,KACAA,KAAAqN,aAAA,IAAAC,EACAtN,KAAAqN,aAAApI,GAAAiD,iBAAA,qBAAAmC,GAAA,OAAAvD,EAAAyG,eAAAlD,MAEAmD,OACAN,oBADA,SACAN,GACA5M,KAAAqN,aAAA3H,OAAAQ,kCAAAlG,KAAAkN,qBAEAD,cAJA,WAKAjN,KAAAgG,SAAA,IAAAhG,KAAAiN,eAAAX,QAAA,GACAtM,KAAAqN,aAAAI,WAAAzN,KAAAgG,WAGA0H,SACAC,eADA,WACA,IAAA9D,EAAA7J,KACAA,KAAAqN,aAAA3H,OAAAQ,kCAAAlG,KAAAkN,oBACAlN,KAAAqN,aAAA3H,OAAAG,6BAAA7F,KAAAmN,sBACAnN,KAAAqN,aAAAM,iBACApF,KAAA,WACAsB,EAAAiD,qBAAA,IAEAzD,MAAA,SAAAC,GACAR,QAAAQ,MAAA,oCAAAA,GACAC,MAAA,oCAAAD,EAAAE,YAGAoE,cAbA,WAcA5N,KAAAqN,aAAAO,gBACA5N,KAAA8M,qBAAA,GAEAS,eAjBA,SAiBAlD,GACAvB,QAAAC,IAAAsB,GACArK,KAAAgN,WAAAvL,KAAA4I,EAAAO,OAAAK,cCnEA4C,GADiB/N,OAFjB,WAA0B,IAAAgO,EAAA9N,KAAaD,EAAA+N,EAAA7N,eAA0BC,EAAA4N,EAAA3N,MAAAD,IAAAH,EAAwB,OAAAG,EAAA,OAAAA,EAAA,OAA2B6N,IAAIC,MAAAF,EAAAH,kBAA4BG,EAAAG,GAAA,kBAAAH,EAAAG,GAAA,KAAA/N,EAAA,MAAA4N,EAAAG,GAAA,KAAA/N,EAAA,OAAsE6N,IAAIC,MAAAF,EAAAF,iBAA2BE,EAAAG,GAAA,kBAAAH,EAAAG,GAAA,KAAA/N,EAAA,MAAA4N,EAAAG,GAAA,KAAAH,EAAAI,GAAAJ,EAAA,oBAAA7C,EAAAkD,GAA4G,OAAAjO,EAAA,OAAiB4L,IAAAb,EAAAC,KAAiBhL,EAAA,SAAcE,OAAOgO,IAAAnD,EAAAD,QAAAqD,SAAA,eAA+C,IAE1b/N,oBCCjB,IAuBAgO,EAvBA9N,EAAA,OAcA+N,CACA9B,EACAoB,GATA,EAVA,SAAAlN,GACAH,EAAA,SAaA,KAEA,MAUA,QCtBAgO,EAAA,EAAIC,IAAIC,EAAA,GAER,IAAAC,EAAA,IAAmBD,EAAA,GACjBE,SAEIC,KAAM,IACNnO,KAAM,aACNoO,UAAWR,MCLjBE,EAAA,EAAI9I,OAAOqJ,eAAgB,EAG3B,IAAIP,EAAA,GACFQ,GAAI,OACJL,SACAM,YAAcC,IAAA3O,GACd4O,SAAU","file":"static/js/app.8d2a6a9c6e254513e280.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"app\"}},[_c('router-view')],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-1e12c2e0\",\"hasScoped\":false,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/App.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-1e12c2e0\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../node_modules/vue-loader/lib/selector?type=styles&index=0!./App.vue\")\n}\nvar normalizeComponent = require(\"!../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./App.vue\"\nimport __vue_script__ from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./App.vue\"\n/* template */\nimport __vue_template__ from \"!!../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-1e12c2e0\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../node_modules/vue-loader/lib/selector?type=template&index=0!./App.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/App.vue\n// module id = null\n// module chunks = ","<template>\n  <div id=\"app\">\n    <router-view/>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'App'\n}\n</script>\n\n<style>\n#app {\n  font-family: 'Avenir', Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/App.vue","\nexport default function () {\n// Parts copied from https://github.com/chris-rudmin/Recorderjs\n  let BYTES_PER_SAMPLE = 2\n  let recorded = []\n\n  function encode (buffer) {\n    let length = buffer.length\n    let data = new Uint8Array(length * BYTES_PER_SAMPLE)\n    for (let i = 0; i < length; i++) {\n      let index = i * BYTES_PER_SAMPLE\n      let sample = buffer[i]\n      if (sample > 1) {\n        sample = 1\n      }\n      else if (sample < -1) {\n        sample = -1\n      }\n      sample = sample * 32768\n      data[index] = sample\n      data[index + 1] = sample >> 8\n    }\n    recorded.push(data)\n  }\n\n  function dump (sampleRate) {\n    let bufferLength = recorded.length ? recorded[0].length : 0\n    let length = recorded.length * bufferLength\n    let wav = new Uint8Array(44 + length)\n\n    let view = new DataView(wav.buffer)\n\n    // RIFF identifier 'RIFF'\n    view.setUint32(0, 1380533830, false)\n    // file length minus RIFF identifier length and file description length\n    view.setUint32(4, 36 + length, true)\n    // RIFF type 'WAVE'\n    view.setUint32(8, 1463899717, false)\n    // format chunk identifier 'fmt '\n    view.setUint32(12, 1718449184, false)\n    // format chunk length\n    view.setUint32(16, 16, true)\n    // sample format (raw)\n    view.setUint16(20, 1, true)\n    // channel count\n    view.setUint16(22, 1, true)\n    // sample rate\n    view.setUint32(24, sampleRate, true)\n    // byte rate (sample rate * block align)\n    view.setUint32(28, sampleRate * BYTES_PER_SAMPLE, true)\n    // block align (channel count * bytes per sample)\n    view.setUint16(32, BYTES_PER_SAMPLE, true)\n    // bits per sample\n    view.setUint16(34, 8 * BYTES_PER_SAMPLE, true)\n    // data chunk identifier 'data'\n    view.setUint32(36, 1684108385, false)\n    // data chunk length\n    view.setUint32(40, length, true)\n\n    for (var i = 0; i < recorded.length; i++) {\n      wav.set(recorded[i], i * bufferLength + 44)\n    }\n\n    recorded = []\n    let msg = [wav.buffer]\n    postMessage(msg, [msg[0]])\n  }\n\n  self.onmessage = function (e) {\n    if (e.data[0] === 'encode') {\n      encode(e.data[1])\n    }\n    else if (e.data[0] === 'dump') {\n      dump(e.data[1])\n    }\n    else if (e.data[0] === 'close') {\n      self.close()\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/shared/encoder-wav-worker.js","// import 'babel-polyfill'\n// import lamejs from 'lamejs'\n\nexport default function () {\n  // Note that relative paths don't work when loaded as a blob\n  // https://stackoverflow.com/questions/22172426/using-importsscripts-within-blob-in-a-karma-environment\n  // importScripts('https://localhost:8443/workers/encoders/lame.js') // eslint-disable-line\n\n  let channels = 1 // 1 for mono or 2 for stereo\n  // let sampleRate = 44100 // 44.1khz (normal mp3 samplerate)\n  let kbps = 128 // encode 128kbps mp3\n\n  let mp3encoder = null\n\n  const maxSamples = 1152\n\n  var mp3Data = [] // array of Uint8Array\n\n  function init (opts) {\n    /* global lamejs */\n    importScripts(opts.baseUrl + '/workers/encoders/lame.min.js') // eslint-disable-line\n    mp3encoder = new lamejs.Mp3Encoder(channels, opts.sampleRate, kbps)\n  }\n\n  function floatTo16BitPCM (input, output) {\n    for (var i = 0; i < input.length; i++) {\n      var s = Math.max(-1, Math.min(1, input[i]))\n      output[i] = (s < 0 ? s * 0x8000 : s * 0x7FFF)\n    }\n  }\n\n  function convertBuffer (arrayBuffer) {\n    var data = new Float32Array(arrayBuffer)\n    var out = new Int16Array(arrayBuffer.length)\n    floatTo16BitPCM(data, out)\n    return out\n  }\n\n  function encode (arrayBuffer) {\n    let samplesMono = convertBuffer(arrayBuffer)\n    let remaining = samplesMono.length\n    for (let i = 0; remaining >= 0; i += maxSamples) {\n      var left = samplesMono.subarray(i, i + maxSamples)\n      var data = mp3encoder.encodeBuffer(left)\n      mp3Data.push(data)\n      remaining -= maxSamples\n    }\n\n    // var mp3buf = mp3encoder.encodeBuffer(buffer)\n    // if (mp3buf.length > 0) {\n    //   mp3Data.push(mp3buf)\n    // }\n  }\n\n  function dump () {\n    var mp3buf = mp3encoder.flush()\n    if (mp3buf.length > 0) {\n      mp3Data.push(mp3buf)\n    }\n\n    // Probably results in native memory copy\n    postMessage(mp3Data)\n\n    // Would like to do this, but not possible because mp3Data is generic array of Uint8Array, and generic\n    // arrays are not transferrable types.\n    // postMessage(mp3Data, [mp3Data])\n\n    // This might help if/when ever become available again\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/transfer\n\n    // For now, though, we have not other option except to build a complete copy in javascript. This means\n    // we temporarily require twice the memory of whatever was recorded.\n\n    mp3Data = []\n  }\n\n  onmessage = function (e) {\n    if (e.data[0] === 'encode') {\n      encode(e.data[1])\n    }\n    else if (e.data[0] === 'dump') {\n      dump(e.data[1])\n    }\n    else if (e.data[0] === 'init') {\n      init(e.data[1])\n    }\n    else if (e.data[0] === 'close') {\n      self.close()\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/shared/encoder-mp3-worker.js","export default function () {\n  let channels = 1\n  let quality = 0.4\n\n  let oggEncoder = null\n\n  let oggData = []\n\n  function init (opts) {\n    /* global OggVorbisEncoder */\n\n    // Possibly required for loading min version, but couldn't get min version to work. Not sure why.\n    // self.OggVorbisEncoderConfig = {\n    //   memoryInitializerPrefixURL: opts.baseUrl + '/workers/encoders/'\n    // }\n\n    // Unable to load min version. Not sure why.  Error in firefox is \"The URI is malformed\". Guessing related to the .mem.\n    importScripts(opts.baseUrl + '/workers/encoders/OggVorbisEncoder.js') // eslint-disable-line\n    oggEncoder = new OggVorbisEncoder(opts.sampleRate, channels, quality)\n  }\n\n  function encode (arrayBuffer) {\n    var data = oggEncoder.encode([arrayBuffer])\n    oggData.push(data)\n  }\n\n  function dump () {\n    let blob = oggEncoder.finish('audio/ogg')\n\n    // this works, but likely results in native memory copy\n    postMessage(blob)\n\n    // Looking at source of OggVorbisEncoder, I think it would be easy to change to allow transferring of the\n    // raw buffer instead.\n\n    // this does not work, I presume because blobs aren't transferrable\n    // postMessage(blob, [blob])\n\n    oggData = []\n  }\n\n  onmessage = function (e) {\n    if (e.data[0] === 'encode') {\n      encode(e.data[1])\n    }\n    else if (e.data[0] === 'dump') {\n      dump(e.data[1])\n    }\n    else if (e.data[0] === 'init') {\n      init(e.data[1])\n    }\n    else if (e.data[0] === 'close') {\n      self.close()\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/shared/encoder-ogg-worker.js","import EncoderWav from './encoder-wav-worker.js'\nimport EncoderMp3 from './encoder-mp3-worker.js'\nimport EncoderOgg from './encoder-ogg-worker.js'\n\nexport default class RecorderService {\n  constructor (baseUrl) {\n    this.baseUrl = baseUrl\n\n    window.AudioContext = window.AudioContext || window.webkitAudioContext\n\n    this.em = document.createDocumentFragment()\n\n    this.state = 'inactive'\n\n    this.chunks = []\n    this.chunkType = ''\n\n    this.usingMediaRecorder = window.MediaRecorder || false\n\t\t\n    this.encoderMimeType = 'audio/wav'\n\n    this.config = {\n      broadcastAudioProcessEvents: false,\n      createAnalyserNode: false,\n      createDynamicsCompressorNode: false,\n      forceScriptProcessor: false,\n      manualEncoderId: 'wav',\n      micGain: 1.0,\n      processorBufferSize: 2048,\n      stopTracksAndCloseCtxWhenFinished: true,\n      userMediaConstraints: {audio: true}\n    }\n  }\n\n  createWorker (fn) {\n    var js = fn\n      .toString()\n      .replace(/^function\\s*\\(\\)\\s*{/, '')\n      .replace(/}$/, '')\n    var blob = new Blob([js])\n    return new Worker(URL.createObjectURL(blob))\n  }\n\n  startRecording (timeslice) {\n    if (this.state !== 'inactive') {\n      return\n    }\n\n    // This is the case on ios/chrome, when clicking links from within ios/slack (sometimes), etc.\n    if (!navigator || !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n      alert('Missing support for navigator.mediaDevices.getUserMedia') // temp: helps when testing for strange issues on ios/safari\n      return\n    }\n\n    this.audioCtx = new AudioContext()\n    this.micGainNode = this.audioCtx.createGain()\n    this.outputGainNode = this.audioCtx.createGain()\n    \n\t\t\n    if (this.config.createDynamicsCompressorNode) {\n      this.dynamicsCompressorNode = this.audioCtx.createDynamicsCompressor()\n    }\n\n    if (this.config.createAnalyserNode) {\n      this.analyserNode = this.audioCtx.createAnalyser()\n    }\n\n    // If not using MediaRecorder(i.e. safari and edge), then a script processor is required. It's optional\n    // on browsers using MediaRecorder and is only useful if wanting to do custom analysis or manipulation of\n    // recorded audio data.\n    if (this.config.forceScriptProcessor || this.config.broadcastAudioProcessEvents || !this.usingMediaRecorder) {\n      this.processorNode = this.audioCtx.createScriptProcessor(this.config.processorBufferSize, 1, 1) // TODO: Get the number of channels from mic\n    }\n\n    // Create stream destination on chrome/firefox because, AFAICT, we have no other way of feeding audio graph output\n    // in to MediaRecorderSafari/Edge don't have this method as of 2018-04.\n    if (this.audioCtx.createMediaStreamDestination) {\n      this.destinationNode = this.audioCtx.createMediaStreamDestination()\n    }\n    else {\n      this.destinationNode = this.audioCtx.destination\n    }\n\n    // Create web worker for doing the encoding\n    if (!this.usingMediaRecorder) {\n      if (this.config.manualEncoderId === 'mp3') {\n        // This also works and avoids weirdness imports with workers\n        // this.encoderWorker = new Worker(BASE_URL + '/workers/encoder-ogg-worker.js')\n        this.encoderWorker = this.createWorker(EncoderMp3)\n        this.encoderWorker.postMessage(['init', {baseUrl: BASE_URL, sampleRate: this.audioCtx.sampleRate}])\n        this.encoderMimeType = 'audio/mpeg'\n      }\n      else if (this.config.manualEncoderId === 'ogg') {\n        this.encoderWorker = this.createWorker(EncoderOgg)\n        this.encoderWorker.postMessage(['init', {baseUrl: BASE_URL, sampleRate: this.audioCtx.sampleRate}])\n        this.encoderMimeType = 'audio/ogg'\n      }\n      else {\n        this.encoderWorker = this.createWorker(EncoderWav)\n        this.encoderMimeType = 'audio/wav'\n      }\n      this.encoderWorker.addEventListener('message', (e) => {\n        let event = new Event('dataavailable')\n        if (this.config.manualEncoderId === 'ogg') {\n          event.data = e.data\n        }\n        else {\n          event.data = new Blob(e.data, {type: this.encoderMimeType})\n        }\n        this._onDataAvailable(event)\n      })\n    }\n\n    // This will prompt user for permission if needed\n    return navigator.mediaDevices.getUserMedia(this.config.userMediaConstraints)\n      .then((stream) => {\n        this._startRecordingWithStream(stream, timeslice)\n        this.microphone = this.audioCtx.createMediaStreamSource(stream) \n\t\t\t\tthis.processor = this.audioCtx.createScriptProcessor(16384, 1, 1)\n\t\t\t\t\n\t\t\t\tthis.microphone.connect(this.processor);  \n        this.processor.connect(this.audioCtx.destination); \n\t\t\t\t\n\t\t\t\t\n\t\t\t\tconsole.log(this.processor)\n\t\t\t\tthis.processor.onaudioprocess = function (event) {  \n\t\t        //边录音边转换  \n\t\t        var array = event.inputBuffer.getChannelData(0)\n\t\t        document.write(array[0]+ '     ')\n\t\t    }; \n\t\t\n      })\n      .catch((error) => {\n        alert('Error with getUserMedia: ' + error.message) // temp: helps when testing for strange issues on ios/safari\n        console.log(error)\n      })\n  }\n\n  setMicGain (newGain) {\n    this.config.micGain = newGain\n    if (this.audioCtx && this.micGainNode) {\n      this.micGainNode.gain.setValueAtTime(newGain, this.audioCtx.currentTime)\n    }\n  }\n\n  _startRecordingWithStream (stream, timeslice) {\n    this.micAudioStream = stream\n\t\t\n    this.inputStreamNode = this.audioCtx.createMediaStreamSource(this.micAudioStream)\n    this.audioCtx = this.inputStreamNode.context\n\t\t\n\t\t\n    // Kind-of a hack to allow hooking in to audioGraph inputStreamNode\n    if (this.onGraphSetupWithInputStream) {\n      this.onGraphSetupWithInputStream(this.inputStreamNode)\n    }\n\n    this.inputStreamNode.connect(this.micGainNode)\n    this.micGainNode.gain.setValueAtTime(this.config.micGain, this.audioCtx.currentTime)\n\n    let nextNode = this.micGainNode\n    if (this.dynamicsCompressorNode) {\n      this.micGainNode.connect(this.dynamicsCompressorNode)\n      nextNode = this.dynamicsCompressorNode\n    }\n\n    this.state = 'recording'\n\n    if (this.processorNode) {\n      nextNode.connect(this.processorNode)\n      this.processorNode.connect(this.outputGainNode)\n      this.processorNode.onaudioprocess = (e) => this._onAudioProcess(e)\n    }\n    else {\n      nextNode.connect(this.outputGainNode)\n    }\n\n    if (this.analyserNode) {\n      // TODO: If we want the analyser node to receive the processorNode's output, this needs to be changed _and_\n      //       processor node needs to be modified to copy input to output. It currently doesn't because it's not\n      //       needed when doing manual encoding.\n      // this.processorNode.connect(this.analyserNode)\n      nextNode.connect(this.analyserNode)\n    }\n\n    this.outputGainNode.connect(this.destinationNode)\n\n    if (this.usingMediaRecorder) {\n      this.mediaRecorder = new MediaRecorder(this.destinationNode.stream)\n      this.mediaRecorder.addEventListener('dataavailable', (evt) => this._onDataAvailable(evt))\n      this.mediaRecorder.addEventListener('error', (evt) => this._onError(evt))\n\n      this.mediaRecorder.start(timeslice)\n    }\n    else {\n      // Output gain to zero to prevent feedback. Seems to matter only on Edge, though seems like should matter\n      // on iOS too.  Matters on chrome when connecting graph to directly to audioCtx.destination, but we are\n      // not able to do that when using MediaRecorder.\n      this.outputGainNode.gain.setValueAtTime(0, this.audioCtx.currentTime)\n      // this.outputGainNode.gain.value = 0\n\n      // Todo: Note that time slicing with manual wav encoderWav won't work. To allow it would require rewriting the encoderWav\n      // to assemble all chunks at end instead of adding header to each chunk.\n      if (timeslice) {\n        console.log('Time slicing without MediaRecorder is not yet supported. The resulting recording will not be playable.')\n        this.slicing = setInterval(function () {\n          if (this.state === 'recording') {\n            this.encoderWorker.postMessage(['dump', this.context.sampleRate])\n          }\n        }, timeslice)\n      }\n    }\n  }\n\n  _onAudioProcess (e) {\n    // console.log('onaudioprocess', e)\n    // let inputBuffer = e.inputBuffer\n    // let outputBuffer = e.outputBuffer\n    // console.log(this.micAudioStream)\n    // console.log(this.audioCtx)\n    // console.log(this.micAudioStream.getTracks().forEach((track) => console.log(track)))\n\n    // this.onAudioEm.dispatch(new Event('onaudioprocess', {inputBuffer:inputBuffer,outputBuffer:outputBuffer}))\n\n    if (this.config.broadcastAudioProcessEvents) {\n      this.em.dispatchEvent(new CustomEvent('onaudioprocess', {\n        detail: {\n          inputBuffer: e.inputBuffer,\n          outputBuffer: e.outputBuffer\n        }\n      }))\n    }\n\n    // // Example handling:\n    // let inputBuffer = e.inputBuffer\n    // let outputBuffer = e.outputBuffer\n    // // Each channel (usually only one)\n    // for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {\n    //   let inputData = inputBuffer.getChannelData(channel)\n    //   let outputData = outputBuffer.getChannelData(channel)\n    //\n    //   // Each sample\n    //   for (let sample = 0; sample < inputBuffer.length; sample++) {\n    //     // Make output equal to the same as the input (thus processor is doing nothing at this time)\n    //     outputData[sample] = inputData[sample]\n    //   }\n    // }\n\n    // When manually encoding (safari/edge), there's no reason to copy data to output buffer.  We set the output\n    // gain to 0 anyways (which is required on Edge if we did copy data to output). However, if using a MediaRecorder\n    // and a processor (all other browsers), then it would be required to copy the data otherwise the graph would\n    // generate no data for the MediaRecorder to consume.\n    // if (this.forceScriptProcessor) {\n\n    // // Copy input to output\n    // let inputBuffer = e.inputBuffer\n    // let outputBuffer = e.outputBuffer\n    // // This doesn't work on iOS/Safari. Guessing it doesn't have copyToChannel support, but haven't verified.\n    // for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {\n    //   outputBuffer.copyToChannel(inputBuffer.getChannelData(channel), channel)\n    // }\n\n    // Safari and Edge require manual encoding via web worker. Single channel only for now.\n    // Example stereo encoderWav: https://github.com/MicrosoftEdge/Demos/blob/master/microphone/scripts/recorderworker.js\n    if (!this.usingMediaRecorder) {\n      if (this.state === 'recording') {\n        if (this.config.broadcastAudioProcessEvents) {\n          this.encoderWorker.postMessage(['encode', e.outputBuffer.getChannelData(0)])\n        }\n        else {\n          this.encoderWorker.postMessage(['encode', e.inputBuffer.getChannelData(0)])\n        }\n      }\n    }\n  }\n\n  stopRecording () {\n    if (this.state === 'inactive') {\n      return\n    }\n    if (this.usingMediaRecorder) {\n      this.state = 'inactive'\n      this.mediaRecorder.stop()\n    }\n    else {\n      this.state = 'inactive'\n      this.encoderWorker.postMessage(['dump', this.audioCtx.sampleRate])\n      clearInterval(this.slicing)\n\n      // TODO: There should be a more robust way to handle this\n      // Without something like this, I think  the last recorded sample could be lost due to timing\n      // setTimeout(() => {\n      //   this.state = 'inactive'\n      //   this.encoderWorker.postMessage(['dump', this.audioCtx.sampleRate])\n      // }, 100)\n    }\n  }\n\n  _onDataAvailable (evt) {\n    // console.log('state', this.mediaRecorder.state)\n    // console.log('evt.data', evt.data)\n\n    this.chunks.push(evt.data)\n    this.chunkType = evt.data.type\n\n    if (this.state !== 'inactive') {\n      return\n    }\n\n    let blob = new Blob(this.chunks, {'type': this.chunkType})\n    let blobUrl = URL.createObjectURL(blob)\n    const recording = {\n      ts: new Date().getTime(),\n      blobUrl: blobUrl,\n      mimeType: blob.type,\n      size: blob.size\n    }\n\n    this.chunks = []\n    this.chunkType = null\n\n    if (this.destinationNode) {\n      this.destinationNode.disconnect()\n      this.destinationNode = null\n    }\n    if (this.outputGainNode) {\n      this.outputGainNode.disconnect()\n      this.outputGainNode = null\n    }\n    if (this.analyserNode) {\n      this.analyserNode.disconnect()\n      this.analyserNode = null\n    }\n    if (this.processorNode) {\n      this.processorNode.disconnect()\n      this.processorNode = null\n    }\n    if (this.encoderWorker) {\n      this.encoderWorker.postMessage(['close'])\n      this.encoderWorker = null\n    }\n    if (this.dynamicsCompressorNode) {\n      this.dynamicsCompressorNode.disconnect()\n      this.dynamicsCompressorNode = null\n    }\n    if (this.micGainNode) {\n      this.micGainNode.disconnect()\n      this.micGainNode = null\n    }\n    if (this.inputStreamNode) {\n      this.inputStreamNode.disconnect()\n      this.inputStreamNode = null\n    }\n\n    if (this.config.stopTracksAndCloseCtxWhenFinished) {\n      // This removes the red bar in iOS/Safari\n      this.micAudioStream.getTracks().forEach((track) => track.stop())\n      this.micAudioStream = null\n\n      this.audioCtx.close()\n      this.audioCtx = null\n    }\n\n    this.em.dispatchEvent(new CustomEvent('recording', {detail: {recording: recording}}))\n  }\n\n  _onError (evt) {\n    console.log('error', evt)\n    this.em.dispatchEvent(new Event('error'))\n    alert('error:' + evt) // for debugging purposes\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/shared/RecorderService.js","export class Utils {\n  // https://stackoverflow.com/a/14919494\n  humanFileSize (bytes, si) {\n    var thresh = si ? 1000 : 1024\n    if (Math.abs(bytes) < thresh) {\n      return bytes + ' B'\n    }\n    var units = si\n      ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n      : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']\n    var u = -1\n    do {\n      bytes /= thresh\n      ++u\n    } while (Math.abs(bytes) >= thresh && u < units.length - 1)\n    return bytes.toFixed(1) + ' ' + units[u]\n  }\n\n  /**\n   * Check user agent for Safari on iOS\n   * @returns {boolean}\n   */\n  isIosSafari () {\n    return navigator.userAgent.match(/iP(od|hone|ad)/) &&\n      navigator.userAgent.match(/AppleWebKit/) &&\n      !navigator.userAgent.match(/(Cr|Fx|OP)iOS/)\n  }\n}\n\nexport default new Utils()\n\n\n\n// WEBPACK FOOTER //\n// ./src/shared/Utils.js","<template>\n\t<div>\n\t\t<div @click=\"startRecording\">\n\t  \t开始\n\t  </div>\n\t  <br />\n\t  <div @click=\"stopRecording\">\n\t  \t停止\n\t  </div>\n\t  <br />\n\t  <div v-for=\"(recording,idx) in recordings\" :key=\"recording.ts\">\n\t\t  <audio :src=\"recording.blobUrl\" controls=\"true\"/>\n\t\t</div>\r\n\t</div>\n</template>\n\n<script>\nimport RecorderService from '@/shared/RecorderService'\nimport utils from '@/shared/Utils'\n\nexport default {\n  name: 'HelloWorld',\n  filters: {\n    fileSizeToHumanSize (val) {\n      return utils.humanFileSize(val, true)\n    }\n  },\n  data () {\n    return {\n      recordingInProgress: false,\n      supportedMimeTypes: [],\n      recordings: [],\n      micGainSlider: 100,\n      micGain: 1.0,\n      cleanupWhenFinished: true,\n      addDynamicsCompressor: false\n    }\n  },\n  created () {\n    this.recorderSrvc = new RecorderService()\n    this.recorderSrvc.em.addEventListener('recording', (evt) => this.onNewRecording(evt))\n  },\n  watch: {\n    cleanupWhenFinished (val) {\n      this.recorderSrvc.config.stopTracksAndCloseCtxWhenFinished = this.cleanupWhenFinished\n    },\n    micGainSlider () {\n      this.micGain = (this.micGainSlider * 0.01).toFixed(2)\n      this.recorderSrvc.setMicGain(this.micGain)\n    }\n  },\n  methods: {\n    startRecording () {\n      this.recorderSrvc.config.stopTracksAndCloseCtxWhenFinished = this.cleanupWhenFinished\n      this.recorderSrvc.config.createDynamicsCompressorNode = this.addDynamicsCompressor\n      this.recorderSrvc.startRecording()\n        .then(() => {\n          this.recordingInProgress = true\n        })\n        .catch((error) => {\n          console.error('Exception while start recording: ' + error)\n          alert('Exception while start recording: ' + error.message)\n        })\n    },\n    stopRecording () {\n      this.recorderSrvc.stopRecording()\n      this.recordingInProgress = false\n    },\n    onNewRecording (evt) {\n    \tconsole.log(evt)\n      this.recordings.push(evt.detail.recording)\n    }\n  }\n}\n</script>\n<style>\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/HelloWorld.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{on:{\"click\":_vm.startRecording}},[_vm._v(\"\\n  \\t开始\\n  \")]),_vm._v(\" \"),_c('br'),_vm._v(\" \"),_c('div',{on:{\"click\":_vm.stopRecording}},[_vm._v(\"\\n  \\t停止\\n  \")]),_vm._v(\" \"),_c('br'),_vm._v(\" \"),_vm._l((_vm.recordings),function(recording,idx){return _c('div',{key:recording.ts},[_c('audio',{attrs:{\"src\":recording.blobUrl,\"controls\":\"true\"}})])})],2)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-795728db\",\"hasScoped\":false,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/HelloWorld.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-795728db\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../node_modules/vue-loader/lib/selector?type=styles&index=0!./HelloWorld.vue\")\n}\nvar normalizeComponent = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./HelloWorld.vue\"\nimport __vue_script__ from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./HelloWorld.vue\"\n/* template */\nimport __vue_template__ from \"!!../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-795728db\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../node_modules/vue-loader/lib/selector?type=template&index=0!./HelloWorld.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/HelloWorld.vue\n// module id = null\n// module chunks = ","import Vue from 'vue'\nimport Router from 'vue-router'\nimport HelloWorld from '@/components/HelloWorld'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      name: 'HelloWorld',\n      component: HelloWorld\n    }\n  ]\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/router/index.js","// The Vue build version to load with the `import` command\n// (runtime-only or standalone) has been set in webpack.base.conf with an alias.\nimport Vue from 'vue'\nimport App from './App'\nimport router from './router'\n\nVue.config.productionTip = false\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  components: { App },\n  template: '<App/>'\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js"],"sourceRoot":""}